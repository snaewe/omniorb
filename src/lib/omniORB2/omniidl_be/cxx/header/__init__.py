# -*- python -*-
#                           Package   : omniidl
# __init__.py               Created on: 1999/11/3
#			    Author    : David Scott (djs)
#
#    Copyright (C) 1999 AT&T Laboratories Cambridge
#
#  This file is part of omniidl.
#
#  omniidl is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
#  02111-1307, USA.
#
# Description:
#
#   Entrypoint to header generation code

# $Id$
# $Log$
# Revision 1.9  2000/01/11 11:34:27  djs
# Added support for fragment generation (-F) mode
#
# Revision 1.8  2000/01/10 17:18:14  djs
# Removed redundant code.
#
# Revision 1.7  1999/12/24 18:14:29  djs
# Fixed handling of #include'd .idl files
#
# Revision 1.6  1999/12/13 15:40:26  djs
# Added generation of "flattened" tie templates
#
# Revision 1.5  1999/12/01 17:03:37  djs
# Added new modules
#
# Revision 1.4  1999/11/12 17:18:39  djs
# Lots of header generation bugfixes
#
# Revision 1.3  1999/11/04 19:05:08  djs
# Finished moving code from tmp_omniidl. Regression tests ok.
#
# Revision 1.2  1999/11/03 17:35:11  djs
# Brought more of the old tmp_omniidl code into the new tree
#

# -----------------------------
# Configuration data
from omniidl.be.cxx import config

# -----------------------------
# Output generation functions
import omniidl.be.cxx.header.defs
import omniidl.be.cxx.header.opers
import omniidl.be.cxx.header.poa
import omniidl.be.cxx.header.tie
import omniidl.be.cxx.header.forward
import omniidl.be.cxx.header.marshal

# -----------------------------
# Utility functions
from omniidl.be.cxx import tyutil, util

# -----------------------------
# System functions
import re, sys


def header(stream, filename):
    #guard = re.sub(r"\W", "_", filename)
    
    stream.out("""\
// This file is generated by @Config.program_Name()@- @Config.omniORB_Library_Version()@. Do not edit.
#ifndef __@guard@_hh__
#define __@guard@_hh__
""", Config = config, guard = filename)

def footer(stream):
    stream.out("""\
#endif""")

def defs_fragment(stream, tree):
    """Creates the defs fragment only"""
    filename = config.basename() + config.defs_fragment_suffix()
    header(stream, filename)

    # generate the header definitions
    forward = omniidl.be.cxx.header.forward.__init__(stream)
    tree.accept(forward)
    
    defs = omniidl.be.cxx.header.defs.__init__(stream)
    tree.accept(defs)

    footer(stream)

def opers_fragment(stream, tree):
    """Creates the opers fragment only"""
    filename = config.basename() + config.opers_fragment_suffix()
    header(stream, filename)

    # see o2be_root::produce_hdr and o2be_root::produce_hdr_defs
    opers = omniidl.be.cxx.header.opers.__init__(stream)
    tree.accept(opers)

    marshal = omniidl.be.cxx.header.marshal.__init__(stream)
    tree.accept(marshal)

    footer(stream)

def poa_fragment(stream, tree):
    """Creates the poa fragment only"""
    filename = config.basename() + config.poa_fragment_suffix()
    header(stream, filename)
    
    poa = omniidl.be.cxx.header.poa.__init__(stream)
    tree.accept(poa)

    footer(stream)

def monolithic(stream, tree):
    """Creates one large header with all definitions inside"""

    # inconsistancy- everywhere else transforms "_" into "__"
    # but the old BE doesn't here
    guard = re.sub(r"\W", "_", config.basename())

    header(stream, guard)
    
    stream.out("""\
#ifndef USE_omniORB_logStream
#define USE_omniORB_logStream
#endif

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB3/CORBA.h>
#endif""", Config = config, guard = guard)

    # produce #includes for all files included by the IDL
    for include in config.include_file_names():
        # skip the main file
        if tree.file() == include:
            continue
        
        # the old C++ BE makes orb.idl a special case
        # (might now be a redundant test)
        
        # chop off the current extension and replace with a .hh
        # s/(.*)\./\1\.hh/
        match = re.compile(r"(.*)\.").match(include)
        filename = match.group(1)
        # chop off the directories and just get the filename
        # I bet this causes lots of trouble later...
        elements = re.split(r"/", filename)
        filename = elements[len(elements) - 1]
        filename = filename + config.hdrsuffix()
        # s/\W/_/g
        guardname = tyutil.guardName([filename])

        stream.out("""\
#ifndef __@guardname@_EXTERNAL_GUARD__
#define __@guardname@_EXTERNAL_GUARD__
#include <@filename@>
#endif""", guardname = guardname, filename = filename)

    stream.out("""\
#ifdef USE_stub_in_nt_dll
#ifndef USE_core_stub_in_nt_dll
#define USE_core_stub_in_nt_dll
#endif
#ifndef USE_dyn_stub_in_nt_dll
#define USE_dyn_stub_in_nt_dll
#endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif
""")
    # see o2be_root::produce_hdr and o2be_root::produce_hdr_defs

    # generate the header definitions
    forward = omniidl.be.cxx.header.forward.__init__(stream)
    tree.accept(forward)
    
    defs = omniidl.be.cxx.header.defs.__init__(stream)
    tree.accept(defs)

    tie = omniidl.be.cxx.header.tie.__init__(stream)
    poa = omniidl.be.cxx.header.poa.__init__(stream)
    tree.accept(poa)
    if config.FlatTieFlag():
        tree.accept(tie)

    
    stream.out("""\
#undef _core_attr
#undef _dyn_attr

""", Config = config)
    # see o2be_root::produce_hdr and o2be_root::produce_hdr_defs
    opers = omniidl.be.cxx.header.opers.__init__(stream)
    tree.accept(opers)

    marshal = omniidl.be.cxx.header.marshal.__init__(stream)
    tree.accept(marshal)

    # other stuff
    stream.out("""\
#endif  // __@guard@_hh__""",Config = config, guard = guard)
      


def run(tree):
    if config.FragmentFlag():
        # build the defs file
        defs_filename = config.basename() + config.defs_fragment_suffix() +\
                        config.hdrsuffix()
        defs_stream = util.Stream(open(defs_filename, "w"), 2)
        defs_fragment(defs_stream, tree)

        # build the opers file
        opers_filename = config.basename() + config.opers_fragment_suffix() +\
                         config.hdrsuffix()
        opers_stream = util.Stream(open(opers_filename, "w"), 2)
        opers_fragment(opers_stream, tree)

        # build the poa file
        poa_filename = config.basename() + config.poa_fragment_suffix() +\
                       config.hdrsuffix()
        poa_stream = util.Stream(open(poa_filename, "w"), 2)
        poa_fragment(poa_stream, tree)
    else:
        # build the full header file
        header_filename = config.basename() + config.hdrsuffix()
        stream = util.Stream(open(header_filename, "w"), 2)
        # generate one big chunk of header
        monolithic(stream, tree)

