<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.05">
<TITLE>
 The Dynamic Invocation Interface
</TITLE>
</HEAD>
<BODY >
<A HREF="omniORB010.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Contents"></A>
<A HREF="omniORB012.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1>Chapter&nbsp;11&nbsp;&nbsp; The Dynamic Invocation Interface</H1>
The Dynamic Invocation Interface (or DII) allows applications to
invoke operations on CORBA objects about which they have no static
information. That is to say the application has not been linked with
stub code which performs the remote operation invocation. Thus using
the DII applications may invoke operations on <EM>any</EM> CORBA object,
possibly determining the object's interface dynamically by using an
Interface Repository.
<BR>
<BR>
This chapter presents an overview of the Dynamic Invocation Interface.
A toy example use of the DII can be found in the omniORB distribution
in the <TT>src/examples/dii</TT> directory. The DII makes extensive use
of the type Any, so ensure that you have read chapter&nbsp;<A HREF="omniORB009.html#ch_any">9</A>.
For more information refer to the Dynamic Invocation Interface and C++
Mapping sections of the CORBA specification&nbsp;[<A HREF="omniORB014.html#corba23-spec"><CITE>OMG99a</CITE></A>].<BR>
<BR>
<A NAME="toc59"></A>
<H2>11.1&nbsp;&nbsp; Overview</H2>To invoke an operation on a CORBA object an application needs an
object reference, the name of the operation and a list of the
parameters. In addition the application must know whether the
operation is one-way, what user-defined exceptions it may throw, any
user-context strings which must be supplied, a `context' to take these
values from and the type of the returned value. This information is
given by the IDL interface declaration, and so is normally made
available to the application via the stub code. In the DII this
information is encapsulated in the <TT>CORBA::Request</TT>
pseudo-object.<BR>
<BR>
To perform an operation invocation the application must obtain an
instance of a <TT>Request</TT> object, supply the information listed
above and call one of the methods to actually make the invocation. If
the invocation causes an exception to be thrown then this may be
retrieved and inspected, or the return value on success.<BR>
<BR>
<A NAME="toc60"></A>
<H2>11.2&nbsp;&nbsp; Pseudo Objects</H2>The DII defines a number of psuedo-object types, all defined in the
<TT>CORBA</TT> namespace. These objects behave in many ways like CORBA
objects. They should only be accessed by reference (through
<TT>foo_ptr</TT> or <TT>foo_var</TT>), may not be instantiated directly
and should be released by calling <TT>CORBA::release()</TT><A NAME="text26" HREF="#note26"><SUP><FONT SIZE=2>1</FONT></SUP></A>. A nil reference should only be
represented by <TT>foo::_nil()</TT>.<BR>
<BR>
These pseudo objects, although defined in pseudo-IDL in the
specification do not follow the normal mapping for CORBA objects. In
particular the memory management rules are different---see the CORBA
2.3 specification&nbsp;[<A HREF="omniORB014.html#corba23-spec"><CITE>OMG99a</CITE></A>] for more details. New instances
of these objects may only be created by the ORB. A number of methods
are defined in <TT>CORBA::ORB</TT> to do this.<BR>
<BR>

<H3>11.2.1&nbsp;&nbsp; Request</H3>A <TT>Request</TT> encapsulates a single operation invocation. It may
<EM>not</EM> be re-used---even for another call with the same arguments.<BR>
<BR>
<PRE>
class Request {
public:
  virtual Object_ptr        target() const;
  virtual const char*       operation() const;
  virtual NVList_ptr        arguments();
  virtual NamedValue_ptr    result();
  virtual Environment_ptr   env();
  virtual ExceptionList_ptr exceptions();
  virtual ContextList_ptr   contexts();
  virtual Context_ptr       ctxt() const;
  virtual void              ctx(Context_ptr);

  virtual Any&amp; add_in_arg();
  virtual Any&amp; add_in_arg(const char* name);
  virtual Any&amp; add_inout_arg();
  virtual Any&amp; add_inout_arg(const char* name);
  virtual Any&amp; add_out_arg();
  virtual Any&amp; add_out_arg(const char* name);

  virtual void set_return_type(TypeCode_ptr tc);
  virtual Any&amp; return_value();

  virtual Status  invoke();
  virtual Status  send_oneway();
  virtual Status  send_deferred();
  virtual Status  get_response();
  virtual Boolean poll_response();

  static Request_ptr _duplicate(Request_ptr);
  static Request_ptr _nil();
};
</PRE>
<H3>11.2.2&nbsp;&nbsp; NamedValue</H3>A pair consisting of a string and a value---encapsulated in an Any.
The name is optional. This type is used to encapsulate parameters and
returned values.<BR>
<BR>
<PRE>
class NamedValue {
public:
  virtual const char* name() const;
  // Retains ownership of return value.

  virtual Any* value() const;
  // Retains ownership of return value.

  virtual Flags flags() const;

  static NamedValue_ptr _duplicate(NamedValue_ptr);
  static NamedValue_ptr _nil();
};
</PRE>
<H3>11.2.3&nbsp;&nbsp; NVList</H3>A list of <TT>NamedValue</TT> objects.<BR>
<BR>
<PRE>
class NVList {
public:
  virtual ULong count() const;
  virtual NamedValue_ptr add(Flags);
  virtual NamedValue_ptr add_item(const char*, Flags);
  virtual NamedValue_ptr add_value(const char*, const Any&amp;, Flags);
  virtual NamedValue_ptr add_item_consume(char*,Flags);
  virtual NamedValue_ptr add_value_consume(char*, Any*, Flags);
  virtual NamedValue_ptr item(ULong index);
  virtual Status remove (ULong);

  static NVList_ptr _duplicate(NVList_ptr);
  static NVList_ptr _nil();
};
</PRE>
<H3>11.2.4&nbsp;&nbsp; Context</H3>Represents a set of context strings.<BR>
<BR>
<PRE>
class Context {
public:
  virtual const char* context_name() const;
  virtual CORBA::Context_ptr parent() const;
  virtual CORBA::Status create_child(const char*, Context_out);
  virtual CORBA::Status set_one_value(const char*, const CORBA::Any&amp;);
  virtual CORBA::Status set_values(CORBA::NVList_ptr);
  virtual CORBA::Status delete_values(const char*);
  virtual CORBA::Status get_values(const char* start_scope,
                                   CORBA::Flags op_flags,
                                   const char* pattern,
                                   CORBA::NVList_out values);
  // Throws BAD_CONTEXT if &lt;start_scope&gt; is not found.
  // Returns a nil NVList in &lt;values&gt; if no matches are found.

  static Context_ptr _duplicate(Context_ptr);
  static Context_ptr _nil();
};
</PRE>
<H3>11.2.5&nbsp;&nbsp; ContextList</H3>A <TT>ContextList</TT> is a list of strings, and is used to specify
which strings from the `context' should be sent with an operation.<BR>
<BR>
<PRE>
class ContextList {
public:
  virtual ULong count() const;
  virtual void add(const char* ctxt);
  virtual void add_consume(char* ctxt);
  // consumes ctxt

  virtual const char* item(ULong index);
  // retains ownership of return value

  virtual Status remove(ULong index);

  static ContextList_ptr _duplicate(ContextList_ptr);
  static ContextList_ptr _nil();
};
</PRE>
<H3>11.2.6&nbsp;&nbsp; ExceptionList</H3><TT>ExceptionList</TT>s contain a list of TypeCodes---and are used to
specify which user-defined exceptions an operation may throw.<BR>
<BR>
<PRE>
class ExceptionList {
public:
  virtual ULong count() const;
  virtual void add(TypeCode_ptr tc);
  virtual void add_consume(TypeCode_ptr tc);
  // Consumes &lt;tc&gt;.

  virtual TypeCode_ptr item(ULong index);
  // Retains ownership of return value.

  virtual Status remove(ULong index);

  static ExceptionList_ptr _duplicate(ExceptionList_ptr);
  static ExceptionList_ptr _nil();
};
</PRE>
<H3>11.2.7&nbsp;&nbsp; UnknownUserException</H3>When a user-defined exception is thrown by an operation it is
unmarshalled into a value of type Any. This is encapsulated in an
<TT>UnknownUserException</TT>. This type follows all the usual rules for
user-defined exceptions---it is not a pseudo object, and its resources
may be released by using <TT>delete</TT>.<BR>
<BR>
<PRE>
class UnknownUserException : public UserException {
public:
  UnknownUserException(Any* ex);
  // Consumes &lt;ex&gt; which MUST be a UserException.

  virtual ~UnknownUserException();

  Any&amp; exception();

  virtual void _raise();
  static const UnknownUserException* _downcast(const Exception*);
  static UnknownUserException* _downcast(Exception*);
  static UnknownUserException* _narrow(Exception*); 
  // _narrow is a deprecated function from CORBA 2.2, 
  // use _downcast instead.
};
</PRE>
<H3>11.2.8&nbsp;&nbsp; Environment</H3>An <TT>Environment</TT> is used to hold an instance of a system
exception or an <TT>UnknownUserException</TT>.<BR>
<BR>
<PRE>
class Environment {
  virtual void exception(Exception*);
  virtual Exception* exception() const;
  virtual void clear();

  static Environment_ptr _duplicate(Environment_ptr);
  static Environment_ptr _nil();
};
</PRE><A NAME="toc61"></A>
<H2>11.3&nbsp;&nbsp; Creating Requests</H2><TT>CORBA::Object</TT> defines three methods which may be used to create
a <TT>Request</TT> object which may be used to perform a single
operation invocation on that object:<BR>
<BR>
<PRE>
class Object {
  ...
  Status _create_request(Context_ptr ctx,
                         const char* operation,
                         NVList_ptr arg_list,
                         NamedValue_ptr result,
                         Request_out request,
                         Flags req_flags);

  Status _create_request(Context_ptr ctx,
                         const char* operation,
                         NVList_ptr arg_list,
                         NamedValue_ptr result,
                         ExceptionList_ptr exceptions,
                         ContextList_ptr ctxlist,
                         Request_out request,
                         Flags req_flags);

  Request_ptr _request(const char* operation);
  ...
};
</PRE><TT>operation</TT> is the name of the operation---which is the same as
the name given in IDL. To access attributes the name should be
prefixed by <TT>_get_</TT> or <TT>_set_</TT>.<BR>
<BR>
In the first two cases above the list of parameters may be supplied.
If the parameters are not supplied in these cases, or <TT>_request()</TT>
is used then the parameters (if any) may be specified using the
<TT>add_*_arg()</TT> methods on the <TT>Request</TT>. You must use one
method or the other---not a mixture of the two. For
<EM>in</EM>/<EM>inout</EM> arguments the value must be initialised, for
<EM>out</EM> arguments only the type need be given. Similarly the type
of the result may be specified by passing a <TT>NamedValue</TT> which
contains an Any which has been initialised to contain a value of that
type, or it may be specified using the <TT>set_return_type()</TT> method
of <TT>Request</TT>.<BR>
<BR>
When using <TT>_create_request()</TT>, the management of any pseudo-object
references passed in remains the responsibility of the
application. That is, the values are not consumed---and must be
released using <TT>CORBA::release()</TT>. The CORBA specification is unclear
about when these values may be released, so to be sure of portability
do not release them until after the request has been released. Values
which are not needed need not be supplied---so if no parameters are
specified then it defaults to an empty parameter list. If no result
type is specified then it defaults to void. A <TT>Context</TT> need only
be given if a non-empty <TT>ContextList</TT> is specified. The
<TT>req_flags</TT> argument is not used in the C++ mapping.<BR>
<BR>

<H3>11.3.1&nbsp;&nbsp; Examples</H3>An operation might be specified in IDL as:<BR>
<BR>
<PRE>
short anOpn(in string a);
</PRE>An operation invocation may be created as follows:<BR>
<BR>
<PRE>
CORBA::ORB_var orb = CORBA::ORB_init(argc, argv, "omniORB3");
...
CORBA::NVList_var args;
orb-&gt;create_list(1, args);
*(args-&gt;add(CORBA::ARG_IN)-&gt;value()) &lt;&lt;= (const char*) "Hello World!";

CORBA::NamedValue_var result;
orb-&gt;create_named_value(result);
result-&gt;value()-&gt;replace(CORBA::_tc_short, 0);

CORBA::Request_var req = obj-&gt;_create_request(CORBA::Context::_nil(),
                                        "anOpn", args, result, 0);
</PRE>or alternatively and much more concisely:<BR>
<BR>
<PRE>
CORBA::Request_var req = obj-&gt;_request("anOpn");
req-&gt;add_in_arg() &lt;&lt;= (const char*) "Hello World!";
req-&gt;set_return_type(CORBA::_tc_short);
</PRE><A NAME="toc62"></A>
<H2>11.4&nbsp;&nbsp; Invoking Operations</H2>
<A NAME="dii_invoke"></A>Once the <TT>Request</TT> object has been properly constructed, the
operation may be invoked by calling one of the following methods on
the request object:<BR>
<BR>

<H5> <TT>invoke()</TT></H5>blocks until the request has completed. The application should then
test to see if an exception was raised. Since the CORBA spec is not
clear about whether or not system exceptions should be thrown from
this method, a runtime configuration variable is supplied so that you
can specify the behavior:<BR>
<BR>
<PRE>
namespace omniORB {
  ...
  CORBA::Boolean diiThrowsSysExceptions;
  ...
};
</PRE>If this is FALSE, and the application should call the <TT>env()</TT> method
of the request to retrieve an exception (it returns 0 (nil) if no
exception was generated). If it is TRUE then system exceptions will be
thrown out of <TT>invoke()</TT>. User-defined exceptions are always passed
via <TT>env()</TT>, which will return a pointer to a
<TT>CORBA::UnknownUserException</TT>. The application can determine
which type of exception was returned by <TT>env()()</TT> by calling the
<TT>_narrow()</TT> method defined for each exception type.<BR>
<BR>
<HR SIZE=2><DL COMPACT=compact>
<DT><DD>
<DIV ALIGN=center><B>Warning</B></DIV><BR>
In pre-omniORB 2.8.0 releases, the default value of
<TT>diiThrowsSysExceptions</TT> is FALSE. From omniORB 2.8.0 onwards,
the default value is TRUE.</DL><HR SIZE=2><BR>
<BR>
After determining that no exception was thrown the application may
retrieve any returned values by calling <TT>return_value()</TT> and
<TT>arguments()</TT>.<BR>
<BR>

<H5> <TT>send_oneway()</TT></H5>has the same semantics as a <EM>oneway</EM> IDL operation. It is
important to note that oneway operations have at-most-once semantics,
and it is not guaranteed that they will not block. Any operation may
be invoked `oneway' using the DII, even if it was not declared as
`oneway' in IDL. A system exception may be generated, in which case it
will either be thrown or may be retrieved using <TT>env()</TT> depending on
<TT>diiThrowsSysExceptions</TT> as above.<BR>
<BR>

<H5> <TT>send_deferred()</TT></H5>initiates the invocation, and then returns without waiting for the
result. At some point in the future the application must retrieve the
result of the operation---but other than testing for completion of the
operation the application must not call any of the request's methods
in the meantime.<BR>
<BR>
<UL>
<LI>
 <TT>get_response()</TT> blocks until the reply is received.

<LI> <TT>poll_response()</TT> returns TRUE if the reply has been received,
 and FALSE if not. It does not block.
</UL>Once <TT>poll_response()</TT> has returned TRUE, or <TT>get_response()</TT> has
been called and returned, the application may test for an exception
and retrieve returned values as above. If
<TT>diiThrowsSysExceptions</TT> is true, then a system exception may be
thrown from <TT>get_response()</TT>. From omniORB 2.8.0 onwards,
<TT>poll_response()</TT> will raise a system exception if one has occurred
during the invocation. Previously, <TT>poll_response()</TT> would not raise
an exception, so if polling, the application also had to call another
method to give the request an opportunity to raise the exception. This
could be one of the methods to retrieve values from the request, or
<TT>get_response()</TT>.<BR>
<BR>
<A NAME="toc63"></A>
<H2>11.5&nbsp;&nbsp; Multiple Requests</H2>The following methods are provided by the ORB to enable multiple requests to
be invoked asynchronously.<BR>
<BR>
<PRE>
namespace CORBA {
  ...
  class ORB {
  public:
    ...
    Status send_multiple_requests_oneway(const RequestSeq&amp;);
    Status send_multiple_requests_deferred(const RequestSeq&amp;);
    Boolean poll_next_response();
    Status get_next_response(Request_out);
    ...
  };
  ...
};
</PRE>
<H5> <TT>send_multiple_requests_oneway()</TT></H5>is used to invoke a number of oneway requests. An attempt will be made
to invoke each of the requests, even if one or more of the early
requests fails. The application may check for failure of any of the
requests by testing the request's <TT>env()</TT> method. System exceptions
are never raised by this method.<BR>
<BR>

<H5> <TT>send_multiple_requests_deferred()</TT></H5>will initiate an invocation of each of the given requests, and return
without waiting for the reply. At some point in the future the
application must retrieve the reply by calling
<TT>get_next_response()</TT>, which returns a completed request. If no
requests have yet completed it will block. This method never throws
exceptions---the request's <TT>env()</TT> method must be used to determine
if an exception was generated. If not then any returned values may
then be queried.<BR>
<BR>
<TT>poll_next_response()</TT> returns TRUE if there are any completed
requests, and FALSE otherwise, without blocking. If this returns true
then the next call to <TT>get_next_response()</TT> will not block.
However, if another thread may also be calling
<TT>get_next_response()</TT> then it could retrieve the completed message
first---in which case this thread might block.<BR>
<BR>
There are no guarantee as to the order in which replies will be
received. If multiple threads are using this interface then it is not
even guaranteed that a thread will receive replies to the requests it
sent. Any thread may receive replies to requests sent by any other
thread. It is legal to call <TT>get_next_response()</TT> even if no
requests have yet been invoked---in which case the calling thread
blocks until another thread invokes a request and the reply is
received.<BR>
<BR>
<HR WIDTH="50%" SIZE=1><DL>
<DT><A NAME="note26" HREF="#text26"><FONT SIZE=5>1</FONT></A><DD> if not
managed by a <TT>_var</TT> type.
</DL>
<HR>
<A HREF="omniORB010.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Contents"></A>
<A HREF="omniORB012.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
