<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.06">
<TITLE>
 Interface Type Checking
</TITLE>
</HEAD>
<BODY >
<A HREF="omniORB007.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="omniORB009.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1><A NAME="htoc86">Chapter&nbsp;7</A>&nbsp;&nbsp;Interface Type Checking</H1>
<A NAME="ch_intf"></A>
This chapter describes the mechanism used by omniORB to ensure type
safety when object references are exchanged across the network. This
mechanism is handled completely within the ORB. There is no
programming interface visible at the application level. However, for
the sake of diagnosing the problem when there is a type violation, it
is useful to understand the underlying mechanism in order to interpret
the error conditions reported by the ORB.<BR>
<BR>
<A NAME="toc34"></A>
<H2><A NAME="htoc87">7.1</A>&nbsp;&nbsp;Introduction</H2>
In GIOP/IIOP, an object reference is encoded as an Interoperable
Object Reference (IOR) when it is sent across a network connection.
The IOR contains a Repository ID (RepoId) and one or more
communication profiles. The communication profiles describe where and
how the object can be contacted. The RepoId is a string which uniquely
identifies the IDL interface of the object.<BR>
<BR>
Unless the <TT>ID</TT> pragma is specified in the IDL, the ORB generates
the RepoId string in the so-called OMG IDL Format<SUP><A NAME="text14" HREF="#note14"><FONT SIZE=2>1</FONT></A></SUP>. For instance, the RepoId for the <TT>Echo</TT>
interface used in the examples of chapter&nbsp;<A HREF="omniORB003.html#chap:basic">25The Basicschapter.2</A> is
<TT>IDL:Echo:1.0</TT>.<BR>
<BR>
When interface inheritance is used in the IDL, the ORB always sends the
RepoId of the most derived interface. For example:
<PRE>
   // IDL
   interface A {
     ...
   };
   interface B : A {
     ...
   };
   interface C {
      void op(in A arg);
   };
</PRE>
<PRE>
   // C++
   C_ptr server;
   B_ptr objB;
   A_ptr objA = objB;
   server-&gt;op(objA);  // Send B as A
</PRE>
In the example, the operation <TT>C::op()</TT> accepts an object reference
of type <TT>A</TT>. The real type of the reference passed to <TT>C::op()</TT>
is <TT>B</TT>, which inherits from <TT>A</TT>. In this case, the RepoId of
<TT>B</TT>, and not that of <TT>A</TT>, is sent across the network.<BR>
<BR>
The GIOP/IIOP specification allows an ORB to send a null string in the
RepoId field of an IOR. It is up to the receiving end to work out the
real type of the object. omniORB never sends out null strings as
RepoId, but it may receive null RepoIds from other ORBs. In that case,
it will use the mechanism described below to ensure type safety.<BR>
<BR>
<A NAME="toc35"></A>
<H2><A NAME="htoc88">7.2</A>&nbsp;&nbsp;Interface Inheritance</H2>
When the ORB receives an IOR of interface type B when it expects the
type to be A, it must find out if B inherits from A. When the ORB has
no local knowledge of the type B, it must work out the type of B
dynamically.<BR>
<BR>
The CORBA specification defines an Interface Repository (IR) from
which IDL interfaces can be queried dynamically. In the above
situation, the ORB could contact the IR to find out the type of B.
However, this approach assumes that an IR is always available and
contains the up-to-date information of all the interfaces used in the
domain. This assumption may not be valid in many applications.<BR>
<BR>
An alternative is to use the <TT>_is_a()</TT> operation to work out the
actual type of an object. This approach is simpler and more robust
than the previous one because no 3rd party is involved, so this is
what omniORB does.
<PRE>
class Object{
    CORBA::Boolean _is_a(const char* type_id);
};
</PRE>
The <TT>_is_a()</TT> operation is part of the <TT>CORBA::Object</TT>
interface and must be implemented by every object. The input argument
is a RepoId. The function returns true(1) if the object is really an
instance of that type, including if that type is a base type of the
most derived type of that object.<BR>
<BR>
In the situation above, the ORB would invoke the <TT>_is_a()</TT>
operation on the object and ask if the object is of type A
<EM>before</EM> it processes any application invocation on the object.<BR>
<BR>
Notice that the <TT>_is_a()</TT> call is <EM>not</EM> performed when the IOR
is unmarshalled. It is performed just prior to the first application
invocation on the object. This leads to some interesting failure modes
if B reports that it is not an A. Consider the following example:
<PRE>
// IDL
interface A { ... };
interface B : A { ... };
interface D { ... };
interface C {
  A      op1();
  Object op2();
};
</PRE>

<PRE>
 1  // C++
 2  C_ptr objC;
 3  A_ptr objA;
 4  CORBA::Object_ptr objR;
 5
 6  objA =  objC-&gt;op1();
 7  (void) objA-&gt;_non_existent();
 8
 9  objR =  objC-&gt;op2();
10  objA =  A::_narrow(objR);
</PRE>
If the stubs of A,B,C,D are linked into the executable and:
<DL COMPACT=compact><DT>
<B>Case 1</B><DD> <TT>C::op1()</TT> and <TT>C::op2()</TT> return a B. Lines 6--10
complete successfully. The remote object is only contacted at line 7.<BR>
<BR>
<DT><B>Case 2</B><DD> <TT>C::op1()</TT> and <TT>C::op2()</TT> return a D. This condition
only occurs if the runtime of the remote end is buggy. The ORB raises
a <TT>CORBA::MARSHAL</TT> exception at line 1 because it knows it has
received an interface of the wrong type.
</DL>
If only the stubs of A are linked into the executable and:
<DL COMPACT=compact><DT>
<B>Case 1</B><DD> <TT>C::op1()</TT> and <TT>C::op2()</TT> return a B. Lines 6--10
complete successfully. When lines 7 and 10 are executed, the object is
contacted to ask if it is an A.<BR>
<BR>
<DT><B>Case 2</B><DD> <TT>C::op1()</TT> and <TT>C::op2()</TT> return a D. This condition
only occurs if the runtime of the remote end is buggy. Line 6
completes and no exception is raised. At line 7, the object is
contacted to ask if it is an A. If the answer is no, a
<TT>CORBA::INV_OBJREF</TT> exception is raised. The application will
also see a <TT>CORBA::INV_OBJREF</TT> at line 10.
</DL>
<HR WIDTH="50%" SIZE=1><DL><DT><A NAME="note14" HREF="#text14"><FONT SIZE=5>1</FONT></A><DD>For further
details of the repository ID formats, see section 10.6 in the CORBA
2.3 specification.
</DL>
<HR>
<A HREF="omniORB007.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="omniORB009.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
