<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!Converted with LaTeX2HTML 95 (Thu Jan 19 1995) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds >
<HEAD>
<TITLE> Introduction</TITLE>
</HEAD>
<BODY>
<meta name="description" value=" Introduction">
<meta name="keywords" value="omniORB2">
<meta name="resource-type" value="document">
<meta name="distribution" value="global">
<P>
 <BR> <HR><A NAME=tex2html239 HREF="node3.html"><IMG ALIGN=BOTTOM ALT="next" SRC="next_motif.gif"></A>   <A NAME=tex2html237 HREF="omniORB2.html"><IMG ALIGN=BOTTOM ALT="up" SRC="up_motif.gif"></A>   <A NAME=tex2html231 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="previous_motif.gif"></A>   <A NAME=tex2html241 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="contents_motif.gif"></A>      <BR>
<B> Next:</B> <A NAME=tex2html240 HREF="node3.html"> The Basics</A>
<B>Up:</B> <A NAME=tex2html238 HREF="omniORB2.html">No Title</A>
<B> Previous:</B> <A NAME=tex2html232 HREF="node1.html">Contents</A>
<BR> <HR> <P>
<H1><A NAME=SECTION00200000000000000000> Introduction</A></H1>
<P>

<P>
OmniORB2 is an Object Request Broker (ORB) that implements the 2.0
specification of the Common Object Request Broker Architecture
(CORBA) [<A HREF="node15.html#corba2spec">OMG96a</A>]<A NAME=tex2html1 HREF="footnode.html#31"><IMG ALIGN=BOTTOM ALT="gif" SRC="foot_motif.gif"></A>.
This user guide tells you how to use omniORB2 to develop CORBA applications.
It assumes a basic understanding of CORBA.
<P>
In this chapter, we give an overview of the main features of omniORB2 and
what you need to do to setup your environment to run omniORB2.
<P>
<H1><A NAME=SECTION00210000000000000000> Features</A></H1>
<P>
<H2><A NAME=SECTION00211000000000000000> CORBA 2 compliant</A></H2>
<P>
OmniORB2 implements the Internet Inter-ORB Protocol (IIOP).
This protocol provides omniORB2 the means of achieving interoperability
with the ORBs implemented by other vendors. In fact, this is the
native protocol used by omniORB2 for the communication amongst its objects
residing in different address spaces. Moreover, the IDL to C++ language
mapping provided by omniORB2 conforms to the latest revision of the CORBA
specification. Type Any and TypeCode are now supported (introduced in version
2.5.0). DynAny is supported since 2.6.0. The Dynamic Invocation Interface
and Dynamic Skeleton Interface are supported since 2.7.0.
<P>
<H2><A NAME=SECTION00212000000000000000> Multithreading</A></H2>
<P>
OmniORB2 is fully multithreaded. To achieve low IIOP call overhead,
unnecessary call-multiplexing is eliminated. At any time, there is at most
one call in-flight in each communication channel between two address
spaces. To do so without limiting the level of concurrency, new channels
connecting the two address spaces are created on demand and cached when
there are more concurrent calls in progress. Each channel is served by a
dedicated thread. This arrangement provides maximal concurrency and
eliminates any thread switching in either of the address spaces to process
a call. Furthermore, to maximise the throughput in processing large call
arguments, large data elements are sent as soon as they are processed while
the other arguments are being marshalled.
<P>
<H2><A NAME=SECTION00213000000000000000> Portability</A></H2>
<P>
At AT&amp;T Laboratories, the ability to target a single source tree to
multiple platforms is
very important. This is difficult to achieve if the IDL to C++ mapping for
these platforms are different. We avoid this problem by making sure that
only one IDL to C++ mapping is used. We run several flavours of Unices, Windows
NT, Windows 95 and our in-house developed systems for our own
hardware. OmniORB2 have been ported to all these platforms. <b> The IDL to
C++ mapping for these targets are all the same</b>.
<P>
OmniORB2 uses real C++ exceptions and nested classes. We stay with the
CORBA specification's standard mapping as much as possible and do not use
the alternative mappings for C++ dialects. The only exception is the
mapping of <b> modules</b>.
<P>
Starting with 2.6.0, the code generated by the IDL compiler of omniORB2 can
be compiled using <b> C++ classes</b> or <b> namespaces</b> to represent IDL
<b> modules</b> depending on the availability of namespace support in the
compiler.
<P>
OmniORB2 relies on the native thread libraries to provide the
multithreading capability. A small class library (omnithread [<A HREF="node15.html#tjr96a">Richardson96a</A>])
is used to encapsulated the (possibly different) APIs of the native thread
libraries. In the application code, it is recommended but not mandatory to
use this class library for thread management. It should be easy to port
omnithread to any platform that either supports the POSIX thread standard
or has a thread package that supports similar capabilities.
<P>
<H2><A NAME=SECTION00214000000000000000> Missing features</A></H2>
<P>
OmniORB2 is not (yet) a complete implementation of the CORBA core. 
The following is a list of the missing features.
<P>
<UL><LI> The BOA only support the persistent server activation policy. Other
dynamic activation and deactivation policies are not supported.
<LI> OmniORB2 does not has its own Interface Repository.
</UL>
<P>
These features may be implemented in the short to medium term. It is
best to check out the latest status on the omniORB2 home page
(<tt> http://www.uk.research.att.com/omniORB/omniORB.html</tt>).
<P>
<H1><A NAME=SECTION00220000000000000000> Setting Up Your Environment</A></H1>
<P>
<A NAME=setup>&#160;</A>
<P>
At AT&amp;T Laboratories Cambridge, you should use the OMNI Development
Environment (ODE) [<A HREF="node15.html#tjr96b">Richardson96b</A>]
and the OMNI tree version 5.0 or above to compile your programs. If this is
the case, there is no extra setup you have to do other than those described
in the ODE documentation.
<P>
If you are running omniORB2 at other sites, you (or your system
administrator) should install omniORB2 by following the instructions in the
installation notes.
<P>
<UL><LI> On Unix platforms, the omniORB2 runtime looks for the environment
variable <tt> OMNIORB_CONFIG</tt>. If this variable is defined, it contains
the pathname of the omniORB2 configuration file. If the variable is not
set, omniORB2 will use the compiled-in pathname to locate the file.
<P>
<LI> On ARM/ATMos, the omniORB2 runtime looks for configuration
information in the file <tt> omniORB.cfg</tt>.
<P>
<LI> On Win32 platforms (Windows NT, Windows '95), omniORB2 first checks the 
environment variable (<tt> OMNIORB2_CONFIG</tt>) to obtain the pathname of the 
configuration file. If this is not set, it then attempts to obtain 
configuration data in the system registry. It searches for the data under 
the key <tt> HKEY_LOCAL_MACHINE<IMG  ALIGN=MIDDLE ALT="" SRC="img1.gif">SOFTWARE<IMG  ALIGN=MIDDLE ALT="" SRC="img2.gif">ORL<IMG  ALIGN=MIDDLE ALT="" SRC="img3.gif">omniORB<IMG  ALIGN=MIDDLE ALT="" SRC="img4.gif">2.0</tt>
<P>
</UL>
<P>
The configuration file is used to obtain an object reference for the
COSS Naming Service. The entry in the configuration file should be specified
in the following form:
<P>
<tt> NAMESERVICE &lt;stringified IOR for the COSS Naming Service&gt;</tt>
<P>
Comments in the configuration file should be prefixed with a #.
<P>
On Win32 platforms, the stringified IOR can be placed in the system registry, 
in the (string) value <tt> NAMESERVICE</tt>, under the key 
<tt> HKEY_LOCAL_MACHINE<IMG  ALIGN=MIDDLE ALT="" SRC="img5.gif">SOFTWARE<IMG  ALIGN=MIDDLE ALT="" SRC="img6.gif">ORL<IMG  ALIGN=MIDDLE ALT="" SRC="img7.gif">omniORB<IMG  ALIGN=MIDDLE ALT="" SRC="img8.gif">2.0</tt>.
<P>
Since 2.6.0, two other entries are supported:
<P>
<PRE>   ORBInitialHost &lt;hostname string&gt;
   ORBInitialPort &lt;port number (1-65535)&gt;
</PRE>
<P>
The corresponding entries under the Win32 system registry is the key with
name <tt> ORBInitialHost</tt> and <tt> ORBInitialPort</tt>.
<P>
The two entries provide information to the ORB to locate a bootstrap
service at runtime. The bootstrap service is able to return the initial
object reference for the COSS Naming Service and others. This is now the
recommended way to configure omniORB2. More details are provided in
section <A HREF="node5.html#bootstrap">4.6</A>.
<P>
<H1><A NAME=SECTION00230000000000000000> Platform specific variables</A></H1>
<P>
To compile omniORB2 programs correctly, several C++ preprocessor defines
<b> must</b> be specified to identify the target platform.
<P>
<P><IMG  ALIGN=BOTTOM ALT="" SRC="img9.gif"><P>
<P>
The preprocessor defines for new platform ports not listed above can be
found in the corresponding platform configuration files. For instance, the 
platform configuration file for Sun Solaris 2.6 is in <tt>
mk/platforms/sun4_sosV_5.6.mk</tt>. The preprocess defines to identify a
platform is the value of the make variable <tt> IMPORT_CPPFLAGS</tt>.
<P>
In a single source multi-target environment, you can put the preprocessor
defines as the command-line arguments for the compiler. Alternately, you could
create a sitedef.h file in the same directory as <tt>
omniORB2/CORBA.h</tt>. Write into the file the appropriate set of preprocessor
defines and add <tt> #include &lt;omniORB2/sitedef.h&gt;</tt> at the beginning of <tt>
omniORB2/CORBA_sysdep.h</tt>.
<P>

<P>
<BR> <HR><A NAME=tex2html239 HREF="node3.html"><IMG ALIGN=BOTTOM ALT="next" SRC="next_motif.gif"></A>   <A NAME=tex2html237 HREF="omniORB2.html"><IMG ALIGN=BOTTOM ALT="up" SRC="up_motif.gif"></A>   <A NAME=tex2html231 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="previous_motif.gif"></A>   <A NAME=tex2html241 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="contents_motif.gif"></A>      <BR>
<B> Next:</B> <A NAME=tex2html240 HREF="node3.html"> The Basics</A>
<B>Up:</B> <A NAME=tex2html238 HREF="omniORB2.html">No Title</A>
<B> Previous:</B> <A NAME=tex2html232 HREF="node1.html">Contents</A>
<BR> <HR> <P>
<BR> <HR>
<P><ADDRESS>
<I>David Riddoch <BR>
Wed Feb 24 14:48:15 GMT 1999</I>
</ADDRESS>
</BODY>
