<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!Converted with LaTeX2HTML 95 (Thu Jan 19 1995) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds >
<HEAD>
<TITLE> The Dynamic Skeleton Interface</TITLE>
</HEAD>
<BODY>
<meta name="description" value=" The Dynamic Skeleton Interface">
<meta name="keywords" value="omniORB2">
<meta name="resource-type" value="document">
<meta name="distribution" value="global">
<P>
 <BR> <HR><A NAME=tex2html364 HREF="node14.html"><IMG ALIGN=BOTTOM ALT="next" SRC="http://www.uk.research.att.com/latex2html/icons/next_motif.gif"></A>   <A NAME=tex2html362 HREF="omniORB2.html"><IMG ALIGN=BOTTOM ALT="up" SRC="http://www.uk.research.att.com/latex2html/icons/up_motif.gif"></A>   <A NAME=tex2html356 HREF="node12.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="http://www.uk.research.att.com/latex2html/icons/previous_motif.gif"></A>   <A NAME=tex2html366 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="http://www.uk.research.att.com/latex2html/icons/contents_motif.gif"></A>      <BR>
<B> Next:</B> <A NAME=tex2html365 HREF="node14.html"> hosts_access(5)</A>
<B>Up:</B> <A NAME=tex2html363 HREF="omniORB2.html">No Title</A>
<B> Previous:</B> <A NAME=tex2html357 HREF="node12.html"> The Dynamic Invocation </A>
<BR> <HR> <P>
<H1><A NAME=SECTION001300000000000000000> The Dynamic Skeleton Interface</A></H1>
<P>

<P>
The Dynamic Skeleton Interface (or DSI) allows applications to provide
implementations of the operations on CORBA objects without static
knowledge of the object's interface. It is the server-side equivalent of the
Dynamic Invocation Interface.
<P>
This chapter presents the Dynamic Skeleton Interface and explains how to
use it.
An toy example use of the DSI can be found in the omniORB2 distribution in
the <tt> &lt;top&gt;/src/examples/dsi</tt> directory.
For further information refer to the Dynamic Skeleton Interface
and C++ Mapping sections of the CORBA 2 specification [<A HREF="node15.html#corba2spec">OMG99a</A>].
<P>
The DSI interface has changed in CORBA 2.3. The implementation described
below conforms to CORBA 2.1 or 2.2.
<P>
<H1><A NAME=SECTION001310000000000000000> Overview</A></H1>
<P>
When an ORB receives an invocation request, the information includes
the object reference and the name of the operation. Typically this information
is used by the
ORB to select an instance of an object and call into the implementation of
the operation (which knows how to unmarshal the parameters etc.).
The Dynamic Skeleton Interface however makes this
information directly available to the application - so that it can
implement the operation (or pass it on to another server) without static
knowledge of the interface. In fact it is not even necessary for the server
to always implement the same interface on any particular object!
<P>
To provide an implementation for one or more objects an application must
sub-class <tt> DynamicImplementation</tt> and override the method <tt> invoke()</tt>.
An instance of this class is registered with the BOA and is assigned an
object reference (see below). When the ORB receives a request for that
object the <tt> invoke()</tt> method is called and will be passed a
<tt> ServerRequest</tt> object which provides:
<UL><LI> the operation name
<LI> context strings
<LI> access to the parameters
<LI> a way to set the returned values
<LI> a way to throw user-defined exceptions.
</UL><H1><A NAME=SECTION001320000000000000000> DSI Types</A></H1>
<P>
<H2><A NAME=SECTION001321000000000000000> DynamicImplementation</A></H2>
<P>
This class must be sub-classed by the application to provide an implementation
for DSI objects. The method <tt> invoke()</tt> will be called for each operation
invocation.
<P>
 <PRE>namespace CORBA {
  ...
  class BOA {
    ...
    class DynamicImplementation {
    public:
      DynamicImplementation();
      virtual ~DynamicImplementation();

      virtual void invoke(ServerRequest_ptr request,
                          Environment&amp; env) throw() = 0;

    protected:
      Object_ptr _this();
      // Must only be called from within invoke(). Caller must release
      // the reference returned.

      BOA_ptr _boa();
      // Must only be called from within invoke(). Caller must NOT
      // release the reference returned.
    };
    ...
  };
  ...
};
</PRE>
<P>
<H2><A NAME=SECTION001322000000000000000> ServerRequest</A></H2>
<P>
A <tt> ServerRequest</tt> object provides the interface between a dynamic
implementation and the ORB.
<P>
 <PRE>namespace CORBA {
  ...
  class ServerRequest {
  public:
    virtual const char*      op_name();
    virtual OperationDef_ptr op_def();
    virtual Context_ptr      ctx();
    virtual void             params(NVList_ptr parameters);
    virtual void             result(Any* value);
    virtual void             exception(Any* value);

    static ServerRequest_ptr _duplicate(ServerRequest_ptr);
    static ServerRequest_ptr _nil();
  };
  ...
};
</PRE>
<P>
<H1><A NAME=SECTION001330000000000000000> Creating Dynamic Implementations</A></H1>
<P>
The application must override the <tt> invoke()</tt> method of
<tt> DynamicImplementation</tt> to provide an implementation for DSI objects.
This method must behave as follows:
<P>
<UL><LI> It may be called concurrently by multiple threads of execution, and
so must be thread-safe.
<LI> It may not throw any exceptions. User-defined exceptions are passed
in a value of type Any and given to <tt> ServerRequest::exception()</tt>. In
pre-omniORB 2.8.0 releases, system exceptions may be passed via the <tt>
env</tt> parameter. From omniORB 2.8.0 onwards, system exceptions can be
inserted into an Any and given to <tt> ServerRequest::exception()</tt> in the
same way as user-defined exceptions. Since the methods provided by <tt>
ServerRequest</tt> may throw system exceptions, the application must catch any
such exception, passed it via <tt> ServerRequest::exception()</tt>.
<LI> The operations on the <tt> ServerRequest</tt> object must be carried out
in the correct order, as described below.
</UL><H2><A NAME=SECTION001331000000000000000> Operations on the ServerRequest</A></H2>
<P>
<tt> op_name()</tt> will return the name of the operation, and may be called at
any time. For attribute access the operation name is the IDL name of the
attribute, prefixed by <tt> _get_</tt> or <tt> _set_</tt>. If the operation name
is not recognised a <tt> CORBA::BAD_OPERATION</tt> exception should be passed
back through <tt> env</tt>. This will allow the ORB to then see if it is one of
the standard object operations.
<P>
Firstly <tt> params()</tt> must be called passing a
<tt> CORBA::NVList</tt><A NAME=tex2html27 HREF="footnode.html#1291"><IMG ALIGN=BOTTOM ALT="gif" SRC="http://www.uk.research.att.com/latex2html/icons/foot_motif.gif"></A>
which must be initialised to contain the type and mode of the parameters.
The ORB consumes this
value and will release it when the operation is complete. At this point any
<em>in</em>/<em>inout</em> arguments will be unmarshalled, and when this operation
returns their values will be in the <tt> NVList</tt>. The application may set
the value of <em>inout</em>/<em>out</em> arguments by modifying this
parameter list.
<P>
If the operation has user-context information, then <tt> ctx()</tt> must be
called after <tt> params()</tt> to retrieve it.
<P>
<tt> result()</tt> must then be called exactly once if the operation has a non-void
return value (unless an exception is thrown). The value passed should be
an Any allocated with <tt> new</tt>, and will be freed by the ORB.
<P>
At any point in the above sequence <tt> exception()</tt> may be called to set
a user-defined exception or a system exception. If this happens then no
further operations should be invoked on the <tt> ServerRequest</tt> object, and
the <tt> invoke()</tt> method should return.
<P>
Within the <tt> invoke()</tt> method <tt> _this()</tt> and <tt> _boa()</tt> may be
called to obtain the object reference and BOA reference respectively. These
methods may not be used at any other time.
<P>
<H1><A NAME=SECTION001340000000000000000> Registering Dynamic Objects</A></H1>
<P>
To use a <tt> DynamicImplementation</tt> a CORBA object must be created and
associated with the implementation. The way in which this is done is not
defined by the CORBA 2.0 specification, so the following method is omniORB2
specific:
<P>
 <PRE>namespace CORBA {
  ...
  class BOA {
    ...
    Object_ptr create_dynamic_object(DynamicImplementation_ptr dir,
                                     const char* intfRepoId);
    ...
  };
  ...
};
</PRE>
<P>
Ownership of the <tt> DynamicImplementation</tt> object is taken over by the ORB,
and it will be deleted when associated the object is destroyed.
The returned object may then be entered into the object table with a call to
<tt> BOA::obj_is_ready()</tt> as usual, and will then start accepting operation
invocations.
<P>
For some applications it will not be possible to register all DSI objects
in advance of invocations arriving. In this case DSI objects can be
created on demand in the same way as normal objects - see
section <A HREF="node6.html#load_on_demand">5.6</A>.
<P>
<H1><A NAME=SECTION001350000000000000000> Example</A></H1>
<P>
This implementation of <tt> DynamicImplementation::invoke()</tt> is taken from
an example which can be found in the omniORB2 distribution. The operation
``echoString'' is declared in IDL as:
<P>
 <PRE>string echoString(in string mesg);
</PRE>
<P>
Here is the Dynamic Implementation Routine:
<P>
 <PRE>void
MyDynImpl::invoke(CORBA::ServerRequest_ptr request, CORBA::Environment&amp; env)
  throw()
{
  try {
    if( strcmp(request-&gt;op_name(), &quot;echoString&quot;) )
      throw CORBA::BAD_OPERATION(0, CORBA::COMPLETED_NO);

    CORBA::NVList_ptr args;
    orb-&gt;create_list(0, args);
    CORBA::Any a;
    a.replace(CORBA::_tc_string, 0);
    args-&gt;add_value(&quot;&quot;, a, CORBA::ARG_IN);

    request-&gt;params(args);

    CORBA::Any&amp; input_any = *(args-&gt;item(0)-&gt;value());
    CORBA::String_var input;
    input_any &gt;&gt;= input.out();

    CORBA::Any* result = new CORBA::Any();
    *result &lt;&lt;= CORBA::Any::from_string(input._retn(), 0);
    request-&gt;result(result);
  }
  catch(CORBA::Exception&amp; ex) {
    CORBA::Any* v = new CORBA::Any;
    ::operator&lt;&lt;=(*v,ex);
    request-&gt;exception(v);
  }
  // In pre-omniORB 2.8.0, one has to do this:
  //  catch(CORBA::SystemException&amp; ex){
  //  env.exception(CORBA::Exception::_duplicate(&amp;ex));
  //  }
  catch(...){
    cout &lt;&lt; &quot;echo_dsiimpl: MyDynImpl::invoke - caught an&quot;
        &quot; unknown exception.&quot; &lt;&lt; endl;
    env.exception(new CORBA::UNKNOWN(0, CORBA::COMPLETED_NO));
  }
}
</PRE>
<P>

<BR> <HR><A NAME=tex2html364 HREF="node14.html"><IMG ALIGN=BOTTOM ALT="next" SRC="http://www.uk.research.att.com/latex2html/icons/next_motif.gif"></A>   <A NAME=tex2html362 HREF="omniORB2.html"><IMG ALIGN=BOTTOM ALT="up" SRC="http://www.uk.research.att.com/latex2html/icons/up_motif.gif"></A>   <A NAME=tex2html356 HREF="node12.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="http://www.uk.research.att.com/latex2html/icons/previous_motif.gif"></A>   <A NAME=tex2html366 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="http://www.uk.research.att.com/latex2html/icons/contents_motif.gif"></A>      <BR>
<B> Next:</B> <A NAME=tex2html365 HREF="node14.html"> hosts_access(5)</A>
<B>Up:</B> <A NAME=tex2html363 HREF="omniORB2.html">No Title</A>
<B> Previous:</B> <A NAME=tex2html357 HREF="node12.html"> The Dynamic Invocation </A>
<BR> <HR> <P>
<BR> <HR>
<P><ADDRESS>
<I>Sai Lai Lo <BR>
Wed Sep 22 19:28:07 BST 1999</I>
</ADDRESS>
</BODY>
